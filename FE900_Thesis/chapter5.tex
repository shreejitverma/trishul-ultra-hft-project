\chapter{Software Control Plane Implementation}

This chapter details the design and implementation of the ultra-low-latency (ULL) software system. This software stack fulfills two critical roles within the broader research framework: it serves as a high-fidelity simulation environment for backtesting the reinforcement learning strategies, and it acts as the operational "Hybrid Control Plane" for the live FPGA system.

\section{Software System Architecture}

The software architecture is designed to minimize non-deterministic behavior introduced by the operating system and hardware caches. It employs a thread-per-core execution model, with critical components communicating via lock-free data structures. The architecture is visualized in Figure \ref{fig:sw_class_diagram}.

\begin{figure}[h!]
    \centering
    \caption{UML Component Diagram of the Software Engine}
    \label{fig:sw_class_diagram}
    \begin{tikzpicture}[node distance=1.5cm, auto]
        \tikzstyle{class} = [rectangle, draw, fill=yellow!10, text width=10em, text centered, rounded corners, minimum height=3em]
        \tikzstyle{line} = [draw, -latex', thick]
        
        \node [class] (oms) {\textbf{OrderManagementSystem} \\ +send\_order() \\ +on\_exec\_report()};
        \node [class, right=of oms] (sor) {\textbf{SmartOrderRouter} \\ +route()};
        \node [class, below=of oms] (strat) {\textbf{MarketMaker} \\ +on\_market\_data() \\ +get\_order()};
        \node [class, left=of strat] (book) {\textbf{OrderBookL2} \\ +update() \\ +best\_bid()};

        \path [line] (strat) -- node [right, scale=0.7] {Quote} (oms);
        \path [line] (oms) -- node [above, scale=0.7] {Route} (sor);
        \path [line] (strat) -- node [above, scale=0.7] {Query} (book);
        \path [line, dashed] (sor) -- node [below, scale=0.7] {OUCH 5.0 Stream} +(2.5,0);
    \end{tikzpicture}
\end{figure}

The event processing pipeline is segmented into six distinct stages:
\begin{enumerate}
    \item \textbf{Ingestion:} A `MulticastReceiver` interfaces with the network stack. To approximate the performance of hardware-based kernel bypass (e.g., DPDK), a `DMARingBuffer` simulation was implemented, allowing the system to process data with \textbf{zero-copy semantics}---a data transfer method that eliminates the need for the CPU to copy data from one memory location to another, significantly reducing latency.
    \item \textbf{Market Data Normalization:} The `ITCHDecoder` parses raw binary messages into semantic events. These events update the `OrderBookL2`, which triggers a `DiffGenerator`. This generator optimizes downstream processing by notifying the strategy only when the Best Bid or Offer (BBO) changes.
\item \textbf{Strategy Execution:} The `MarketMaker` strategy receives BBO updates. It calculates an Order Book Imbalance (OBI) signal and applies a skew to the \textbf{mid-price}---the arithmetic mean of the current best bid and ask prices---to generate optimal quotes.
    \item \textbf{Risk Validation:} A `PretradeChecker` enforces a safety layer, validating every generated order against Position and Notional limits before it is permitted to leave the strategy thread.
    \item \textbf{Order Execution:} Validated orders are encoded into the binary NASDAQ OUCH 5.0 format by the `OUCHCodec` and dispatched to the simulated exchange.
    \item \textbf{Observability:} An `AsyncLogger` captures diagnostic data. By utilizing a lock-free ring buffer, logging operations are offloaded to a background thread, ensuring zero latency penalty on the critical trading path.
\end{enumerate}

\section{Core Implementation Details}

\subsection{Smart Order Router (Hybrid Execution)}
To maximize system efficiency, we implemented a `SmartOrderRouter` (SOR) that dynamically routes orders based on the asset's latency sensitivity. The router inspects the `SymbolInfo` for each order.
\begin{itemize}
    \item \textbf{FPGA Path:} High-priority stocks are routed to the `FPGADriver`, which writes the order details to memory-mapped registers, triggering an immediate hardware dispatch.
    \item \textbf{CPU Path:} Standard assets are routed to the software `GatewaySim`, preserving FPGA resources for the most critical flows.
\end{itemize}
This hybrid approach allows the system to scale to thousands of symbols while ensuring microsecond latency for the top-tier assets.

\subsection{Exchange Simulation (Matching Engine)}
A robust evaluation requires a realistic counterparty. We implemented a fully functional `MatchingEngine` to simulate the exchange. \textit{The matching engine acts like a "referee" that follows strict rules to pair up buyers and sellers fairly based on who arrived first and who has the best price.} This ensures that the strategy is tested against realistic constraints, including queue position and partial fills.

\subsection{Vectorized Signal Engine}
To support the computational demands of the RL strategy, a `SignalEngine` was developed using \textbf{AVX2 SIMD} intrinsics. \textit{SIMD stands for "Single Instruction, Multiple Data," which is like being able to perform the same calculation on a whole row of numbers at once, instead of doing them one by one.} By processing batches of price data in parallel, the software control plane can recalculate model parameters over millions of historical ticks in under 200 milliseconds.

\subsection{Direct Market Access Protocol (OUCH 5.0)}
To ensure the system's readiness for deployment, the text-based order entry protocols often used in academic simulations were replaced with a native `OUCHCodec`. This component strictly adheres to the NASDAQ OUCH 5.0 specification, packing order fields into compact, Little-Endian binary structures. This verifies that the system can interface correctly with production-grade exchange gateways.