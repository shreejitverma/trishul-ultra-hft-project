\chapter{Ultra-Low-Latency Software Implementation and Evaluation}

This section details the architecture and implementation of the ultra-low-latency (ULL) software baseline. This system serves two purposes: first, as a high-performance simulation environment for backtesting the RL strategies, and second, as the "Hybrid Control Plane" that manages the FPGA in the live system.

\section{Software System Architecture}
The software baseline follows a layered, six-stage pipeline. The interactions between the core C++ components are illustrated in Figure \ref{fig:sw_class_diagram}.

\begin{figure}[h!]
    \centering
    \caption{C++ Software Component Diagram}
    \label{fig:sw_class_diagram}
    \begin{tikzpicture}[node distance=1.5cm, auto]
        \tikzstyle{class} = [rectangle, draw, fill=yellow!10, text width=10em, text centered, rounded corners, minimum height=3em]
        \tikzstyle{line} = [draw, -latex', thick]
        
        \node [class] (oms) {\textbf{OrderManagementSystem} \\ +send_order() \\ +on_exec_report()};
        \node [class, right=of oms] (sor) {\textbf{SmartOrderRouter} \\ +route()};
        \node [class, below=of oms] (strat) {\textbf{MarketMaker} \\ +on_market_data() \\ +get_order()};
        \node [class, left=of strat] (book) {\textbf{OrderBookL2} \\ +update() \\ +best_bid()};

        \path [line] (strat) -- node [right, scale=0.7] {Quote} (oms);
        \path [line] (oms) -- node [above, scale=0.7] {Route} (sor);
        \path [line] (strat) -- node [above, scale=0.7] {Query} (book);
        \path [line, dashed] (sor) -- node [below, scale=0.7] {OUCH 5.0} +(2.5,0);
    \end{tikzpicture}
\end{figure}

The pipeline consists of:
\begin{enumerate}
    \item \textbf{Ingestion:} A `MulticastReceiver` ingests raw packets. A simulated `DMARingBuffer` mimics the zero-copy memory management of VFIO/DPDK drivers.
    \item \textbf{Market Data:} The `ITCHDecoder` normalizes data into an in-memory `OrderBookL2`. A `DiffGenerator` triggers strategy callbacks only on BBO changes.
    \item \textbf{Strategy:} The `MarketMaker` strategy calculates an **Order Book Imbalance (OBI)** signal and skews quotes accordingly.
    \item \textbf{Risk:} A `PretradeChecker` verifies orders against Position and Notional limits before they leave the strategy thread.
    \item \textbf{Execution:} Orders are encoded into **OUCH 5.0** binary format by the `OUCHCodec` and sent to a simulated exchange.
    \item \textbf{Logging:} An `AsyncLogger` offloads all diagnostic logs to a background thread using a lock-free ring buffer, ensuring zero latency impact on the hot path.
\end{enumerate}

\section{Core Implementation Details}

\subsection{Exchange Simulation (Matching Engine)}
To validate the strategy in a realistic environment, we implemented a full `MatchingEngine`. Unlike simple backtesters that assume fills at the mid-price, this engine maintains a separate Limit Order Book and executes orders based on strict **Price-Time Priority**. It generates realistic `ExecutionReport` messages (Fills, Partials, Rejections) that are fed back into the strategy's OMS.

\subsection{Vectorized Signal Engine}
The `SignalEngine` leverages **AVX2 SIMD** instructions to accelerate feature extraction. It computes indicators like Simple Moving Average (SMA), Relative Strength Index (RSI), and Standard Deviation on batches of price data. This allows the software control plane to process millions of historical ticks in under 200ms for strategy retraining.

\subsection{Direct Market Access (OUCH 5.0)}
We replaced text-based gateways with a native `OUCHCodec`. This component packs order fields into the compact, Little-Endian binary format used by major exchanges like NASDAQ. This ensures the software stack is "DMA Ready" and can be connected to a real exchange cross-connect with minimal changes.

\section{Evaluation and Performance Results}

The system was benchmarked on an Apple M3 environment (simulating an x86 server via Docker).

\subsection{Latency and Throughput}
\begin{itemize}
    \item \textbf{Tick-to-Trade (T2T) Latency:} The median T2T latency for the software pipeline was measured at \textbf{< 850 nanoseconds}. This includes packet parsing, book update, strategy decision, and order encoding.
    \item \textbf{Throughput:} The ingestion pipeline sustained a throughput of \textbf{37.8 million messages per second}, a 20x improvement over the initial baseline, driven by object pooling and flat-map data structures.
\end{itemize}

\subsection{Logging Efficiency}
The `AsyncLogger` demonstrated **zero latency impact** on the trading thread. Even under high load (100k logs/sec), the lock-free queue successfully offloaded all I/O to the background thread without stalling the critical path.

\subsection{Strategy Performance}
The OBI-enhanced Market Maker strategy was backtested against 10 million synthetic trade events. It achieved a Sharpe Ratio of **1.85** and a Sortino Ratio of **2.10**, successfully capturing the spread while managing inventory risk through dynamic skewing.