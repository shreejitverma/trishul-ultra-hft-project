\appendix
\chapter{Appendix}

\section{Setup Guide: Verilog on Apple Silicon}

\begin{enumerate}
    \item \textbf{Install Apple's Command Line Utilities}
    
    The first step is to install Apple's command line developer tools. This will provide you with essential tools like \texttt{git} and a compiler. Open your terminal and run the following command: 
    
    \begin{verbatim}
xcode-select --install
    \end{verbatim}
    
    \item \textbf{Install Homebrew}
    
    Homebrew is a package manager for macOS that simplifies the installation of software. To install Homebrew, execute the following command in your terminal:
    
    \begin{verbatim}
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    \end{verbatim}
    
    \item \textbf{Install Verilator and SystemC}
    
    Next, you will install Verilator, a Verilog simulator, and SystemC, a C++ library for system-level modeling. Use Homebrew to install them with this command:
    
    \begin{verbatim}
brew install verilator systemc
    \end{verbatim}
    
    \item \textbf{Install GTKWave}
    
    GTKWave is a waveform viewer that you will use to analyze the simulation results. Install it using Homebrew:
    
    \begin{verbatim}
brew install gtkwave
    \end{verbatim}
    
    \item \textbf{Configure Your Environment}
    
    After installing all the necessary tools, you need to configure your environment. This involves setting up the required environment variables. You will need to add the following lines to your shell configuration file (e.g., \texttt{\textasciitilde/.zshrc} or \texttt{\textasciitilde/.bash\_profile}):
    
    \begin{verbatim}
export SYSTEMC_HOME=/opt/homebrew/opt/systemc
export VERILATOR_ROOT=/opt/homebrew/opt/verilator
export PATH=$VERILATOR_ROOT/bin:$PATH
    \end{verbatim}
    
    After adding these lines, restart your terminal or source the configuration file for the changes to take effect (e.g., \texttt{source \textasciitilde/.zshrc}).

\end{enumerate}

\section{FPGA Code Explanation and Module Overview}
\label{sec:codeexplain}

This section provides an overview of the Verilog and VHDL code implementations that form the backbone of the proposed Tick-to-Trade (T2T) pipeline. The full code listings are provided in Appendix A.

\subsection{Network Ingress Modules}
\textbf{Parser (Listing \ref{lst:parser}):} Extracts Ethernet/IP/UDP headers and market data payloads, forming the entry point of the T2T pipeline.  
\textbf{Multicast Gate (Listing \ref{lst:gate}):} Filters packets based on destination IP and port to ensure only relevant market feeds are processed.

\subsection{Feed Handler Modules}
\textbf{Frame Extractor (Listing \ref{lst:frame}):} Detects message boundaries and aggregates fixed-width data records.  
\textbf{Order Book Update (Listing \ref{lst:book}):} Maintains Level-1 order book data (best bid/ask), continuously updating state with each new message.

\subsection{Strategy and Decision Logic}
\textbf{Strategy Decision Block (Listing \ref{lst:strategy}):} Implements a baseline threshold-based logic for buy/sell signals. This serves as the control baseline for the proposed reinforcement learning (RL) inference core.  
\textbf{Risk Gate (Listing \ref{lst:risk}):} Applies strict hardware-level checks for notional exposure and message rate limits, ensuring compliance and preventing over-trading.

\subsection{Order Transmission Modules}
\textbf{Order Encoder (Listing \ref{lst:encoder}):} Converts validated trade signals into exchange-compatible order messages (FIX/OUCH).  
\textbf{TX Bridge (Listing \ref{lst:tx}):} Manages transmission of encoded orders to the network MAC layer, completing the tick-to-trade path.

\subsection{Control Plane and Integration}
\textbf{AXI-Lite Register Interface (Listing \ref{lst:axi}):} Provides a software-accessible control plane for updating parameters and reading telemetry metrics via PCIe/DMA.  
\textbf{Top-Level Integration (Listing \ref{lst:top}):} Connects all modules into a unified low-latency hardware pipeline, ensuring deterministic data flow from ingress to egress.

Each of these components is designed with deterministic latency in mind, and the overall architecture ensures that all decision-making, order handling, and safety checks occur in hardware to meet sub-microsecond trading requirements.

\section{Appendix: Core Implementation Snippets}
\label{appendix:code}

\noindent \textbf{Note on Source Code:} Due to the extensive nature of the codebase, the full source listings, build scripts, and configuration files are hosted in the project repository at: \\
\url{https://github.com/shreejitverma/trishul-ultra-hft-project}

The following sections provide \textbf{abridged snippets} of the critical modules discussed in the thesis, focusing on the core algorithmic logic and removing standard boilerplate.

%-----------------------------------
\subsection{1. Network Ingress: Parser (Verilog)}
The state machine responsible for zero-copy extraction of UDP payloads from raw Ethernet frames.

\begin{lstlisting}[language=Verilog, caption={Packet Parsing State Machine (Snippet)}, label={lst:parser}]
// (Module ports and declarations omitted for brevity)
always @(posedge clk) begin
    if (rst) begin
        state <= ST_ETH; m_axis_tvalid <= 1'b0;
    end else begin
        // Pipeline control logic
        if (s_axis_tvalid && s_axis_tready) begin
            case(state)
                ST_ETH: state <= ST_IP; // Skip Eth Header
                ST_IP: begin
                    ip_src <= s_axis_tdata[31:0];
                    ip_dst <= s_axis_tdata[63:32];
                    state <= ST_UDP;
                end
                ST_UDP: begin
                    udp_sport <= s_axis_tdata[15:0];
                    udp_dport <= s_axis_tdata[31:16];
                    state <= ST_PAY;
                end
                ST_PAY: begin
                    // Streaming payload to downstream modules
                    m_axis_tdata <= s_axis_tdata;
                    m_axis_tvalid <= 1'b1;
                    if (s_axis_tlast) state <= ST_ETH;
                end
            endcase
        end
    end
end
\end{lstlisting}

\begin{lstlisting}[language=Verilog, caption={Multicast Gate Logic}, label={lst:gate}]
always @(posedge clk) begin
    if (valid_udp) begin
        // Check Dest IP and Port against whitelist
        if (udp_dst_ip == 32'hE9_36_0C_6F && // 233.54.12.111
            udp_dst_port == 16'd5000) begin
            pass <= 1'b1;
        end else begin
            pass <= 1'b0; // Drop packet
        end
    end
end
\end{lstlisting}

%-----------------------------------
\subsection{2. Feed Handler Modules}

\begin{lstlisting}[language=Verilog, caption={Frame Extractor}, label={lst:frame}]
// Accumulates bytes until a full message is received
always @(posedge clk) begin
    if (payload_valid) begin
        buffer <= {buffer[W-9:0], s_axis_tdata};
        count <= count + 1;
        if (count == MSG_LEN) begin
            msg_out <= buffer;
            msg_valid <= 1'b1;
            count <= 0;
        end
    end
end
\end{lstlisting}

\begin{lstlisting}[language=Verilog, caption={Order Book Update Logic}, label={lst:book}]
always @(posedge clk) begin
    if (tick_valid) begin
        if (tick_side == "B" && tick_price > best_bid) begin
            best_bid <= tick_price; // New Best Bid
        end
        if (tick_side == "S" && tick_price < best_ask) begin
            best_ask <= tick_price; // New Best Ask
        end
    end
end
\end{lstlisting}

%-----------------------------------
\subsection{3. Strategy Logic: Decision Block (Verilog)}
The hardware circuit that generates buy/sell signals based on pre-calculated price thresholds.

\begin{lstlisting}[language=Verilog, caption={Hardware Strategy Decision Logic}, label={lst:strategy}]
// Threshold comparison logic
wire buy_cond = (ask_px0 + thresh_buy < fair_px);
wire sell_cond = (bid_px0 - thresh_sell > fair_px);

always @(posedge clk) begin
    if (rst) begin 
        buy <= 1'b0; sell <= 1'b0; out_valid <= 1'b0; 
    end else begin
        out_valid <= 1'b0;
        // Trigger on valid market data update
        if (in_valid) begin
            // Single-cycle decision latency
            buy <= buy_cond; 
            sell <= sell_cond; 
            out_valid <= 1'b1;
        end
    end
end
\end{lstlisting}

%-----------------------------------
\subsection{4. Hardware Pre-Trade Risk Gate (Verilog)}
Ensures strict compliance with notional and message rate limits before order generation.

\begin{lstlisting}[language=Verilog, caption={Risk Check Logic}, label={lst:risk}]
wire [63:0] notional_in = in_px * in_qty;

always @(posedge clk) begin
    if (rst) begin
        notional_accum <= 64'd0; 
        pass <= 1'b0;
    end else begin
        if (in_valid) begin
            // Parallel check of all risk limits
            pass <= enable && 
                   (notional_accum + notional_in <= notional_limit) && 
                   (msg_count + 1 <= msg_rate_limit);
            
            // Update state only if checks pass
            if (enable) begin
                notional_accum <= notional_accum + notional_in;
                msg_count <= msg_count + 1;
            end
        end
    end
end
\end{lstlisting}

%-----------------------------------
\subsection{5. Order Transmission Modules}

\begin{lstlisting}[language=Verilog, caption={Order Encoder (OUCH)}, label={lst:encoder}]
always @(posedge clk) begin
    if (trigger_buy) begin
        // Construct OUCH 'Enter Order' message
        packet[7:0]   <= 8'h4F; // Type 'O'
        packet[39:8]  <= token;
        packet[47:40] <= 8'h42; // 'B'uy
        packet[79:48] <= price;
        // ... (remaining fields)
        tx_valid <= 1'b1;
    end
end
\end{lstlisting}

\begin{lstlisting}[language=Verilog, caption={TX Bridge}, label={lst:tx}]
// Adapts internal parallel bus to AXI-Stream MAC interface
assign m_axis_tdata = packet_shift_reg[63:0];
always @(posedge clk) begin
    if (m_axis_tready) begin
        packet_shift_reg <= packet_shift_reg >> 64;
    end
end
\end{lstlisting}

%-----------------------------------
\subsection{6. Control Plane and Integration}

\begin{lstlisting}[language=Verilog, caption={AXI-Lite Register Interface}, label={lst:axi}]
// Maps PCIe writes to internal control registers
always @(posedge clk) begin
    if (axi_wvalid && axi_wready) begin
        case (axi_awaddr[7:0])
            8'h00: control_reg <= axi_wdata;
            8'h04: risk_limit_reg <= axi_wdata;
            8'h08: strategy_param_reg <= axi_wdata;
        endcase
    end
end
\end{lstlisting}

\begin{lstlisting}[language=Verilog, caption={Top-Level Integration}, label={lst:top}]
module top_wrapper (
    input wire clk,
    input wire [63:0] eth_rx_data,
    output wire [63:0] eth_tx_data
);
    // Instantiate and connect all modules
    rx_parser   u_parser (...);
    book_engine u_book (...);
    strat_core  u_strat (...);
    risk_gate   u_risk (...);
    tx_encoder  u_enc (...);
    // ...
endmodule
\end{lstlisting}

% -----------------------------------------------------
%APPENDIX B: C++ ULL SOFTWARE CODE LISTINGS
% -----------------------------------------------------

\section{Appendix: C++ Software Baseline Snippets}
\label{appendix:code_cpp}

\subsection{1. High-Precision Timing (C++)}
Calibration routine for the RDTSC (Read Time-Stamp Counter) instruction to achieve nanosecond precision.

\begin{lstlisting}[style=cppstyle, caption={RDTSC Calibration Routine}, label={lst:rdtsc}]
void RDTSCClock::calibrate() noexcept {
    constexpr int SAMPLES = 10;
    double factors[SAMPLES];
    
    // Sample system clock vs RDTSC multiple times
    for (int i = 0; i < SAMPLES; ++i) {
        auto sys_start = std::chrono::high_resolution_clock::now();
        uint64_t tsc_start = __rdtscp(&aux);
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        auto sys_end = std::chrono::high_resolution_clock::now();
        uint64_t tsc_end = __rdtscp(&aux);
        
        auto elapsed_ns = std::chrono::duration_cast<std::chrono::nanoseconds>
                          (sys_end - sys_start).count();
        factors[i] = static_cast<double>(elapsed_ns) / (tsc_end - tsc_start);
    }
    
    // Use median factor to reject OS jitter/outliers
    std::sort(factors, factors + SAMPLES);
    tsc_to_ns_factor_.store(factors[SAMPLES / 2], std::memory_order_release);
}
\end{lstlisting}

\subsection{2. RL Strategy Logic (C++)
}
The Avellaneda-Stoikov approximation used as the baseline heuristic strategy.

\begin{lstlisting}[style=cppstyle, caption={Heuristic Strategy Inference Logic}, label={lst:nn}]
void RLPolicyStrategy::run_inference() noexcept {
    auto bbo_bid = order_book_.best_bid();
    auto bbo_ask = order_book_.best_ask();
    if (bbo_bid.price == 0 || bbo_ask.price == INVALID_PRICE) return;

    // 1. Feature Extraction
    double mid_price = (bbo_bid.price + bbo_ask.price) / 2.0;
    
    // 2. Model Parameters (Tuned or Learned)
    double gamma = 0.1;       // Risk aversion
    double sigma = 2.0;       // Volatility proxy
    
    // 3. Avellaneda-Stoikov Approximation
    // Adjust reservation price based on current inventory
    double inventory_risk_adj = current_inventory_ * gamma * (sigma * sigma); 
    double reservation_price = mid_price - inventory_risk_adj;
    
    // Calculate optimal spread centered on reservation price
    double half_spread = (sigma * 5000.0); 
    if (half_spread < (bbo_ask.price - bbo_bid.price)/2.0) {
        half_spread = (bbo_ask.price - bbo_bid.price)/2.0; 
    }

    Price optimal_bid = static_cast<Price>(reservation_price - half_spread);
    Price optimal_ask = static_cast<Price>(reservation_price + half_spread);
    
    // 4. Order Generation (Quantized to tick size)
    // (Order construction code omitted...)
    if (optimal_bid > 0) order_queue_.push(buy_order);
    if (optimal_ask > optimal_bid) order_queue_.push(sell_order);
}
\end{lstlisting}

\subsection{3. Zero-Copy Parser (C++)
}
Optimized Ethernet header parsing using pointer arithmetic.

\begin{lstlisting}[style=cppstyle, caption={Ethernet/IP/UDP Header Parsing}, label={lst:cpp_parser}]
ParsedPacket parse(const uint8_t* packet, size_t len, Timestamp ts) noexcept {
    ParsedPacket result{};
    result.timestamp_ns = ts;
    
    // Fast checks for packet validity
    if (ULTRA_UNLIKELY(len < 42)) return result;
    
    const auto* eth = reinterpret_cast<const EthernetHeader*>(packet);
    if (ULTRA_UNLIKELY(ntohs_fast(eth->ethertype) != 0x0800)) return result; // IPv4
    
    const auto* ip = reinterpret_cast<const IPv4Header*>(packet + 14);
    if (ULTRA_UNLIKELY(ip->protocol != 17)) return result; // UDP
    
    // Extract pointers directly from buffer (Zero-Copy)
    const uint8_t ip_hdr_len = (ip->version_ihl & 0x0F) * 4;
    const size_t header_len = 14 + ip_hdr_len + 8; // Eth + IP + UDP
    
    result.payload = packet + header_len;
    result.payload_len = len - header_len;
    result.valid = true;
    return result;
}
\end{lstlisting}